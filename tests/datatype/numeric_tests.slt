# Generated from datatypes_numeric_tests.json
# Total test cases: 85

# Test Case 1/85
# 数值类型-INT-基本测试
# 测试INT类型的基本功能

statement ok
DROP TABLE IF EXISTS test_int_basic;


statement ok
CREATE TABLE test_int_basic (id INT, col_int INT);

statement ok
INSERT INTO test_int_basic VALUES (1, 12345), (2, -9876), (3, 0);

query TT
SELECT id, col_int FROM test_int_basic ORDER BY id;
----
1 12345
2 -9876
3 0

statement ok
DROP TABLE test_int_basic;


# Test Case 2/85
# 数值类型-INT-边界测试最大值
# 测试INT类型的最大值2147483647

statement ok
DROP TABLE IF EXISTS test_int_max;


statement ok
CREATE TABLE test_int_max (id INT, col_int INT);

statement ok
INSERT INTO test_int_max VALUES (1, 2147483647);

query T
SELECT col_int FROM test_int_max;
----
2147483647

statement ok
DROP TABLE test_int_max;


# Test Case 3/85
# 数值类型-INT-边界测试最小值
# 测试INT类型的最小值-2147483648

statement ok
DROP TABLE IF EXISTS test_int_min;


statement ok
CREATE TABLE test_int_min (id BIGINT, col_int INT);

statement ok
INSERT INTO test_int_min VALUES (1, -2147483648);

query T
SELECT col_int FROM test_int_min;
----
-2147483648

statement ok
DROP TABLE test_int_min;


# Test Case 4/85
# 数值类型-INT-溢出测试
# 测试INT类型超出范围的错误处理

statement ok
DROP TABLE IF EXISTS test_int_overflow;


statement ok
CREATE TABLE test_int_overflow (id INT, col_int INT);

statement error
INSERT INTO test_int_overflow VALUES (1, 2147483648);

statement ok
DROP TABLE test_int_overflow;


# Test Case 5/85
# 数值类型-BIGINT-基本测试
# 测试BIGINT类型的基本功能

statement ok
DROP TABLE IF EXISTS test_bigint_basic;


statement ok
CREATE TABLE test_bigint_basic (id INT, col_bigint BIGINT);

statement ok
INSERT INTO test_bigint_basic VALUES (1, 123456789012345), (2, -987654321098765), (3, 0);

query TT
SELECT id, col_bigint FROM test_bigint_basic ORDER BY id;
----
1 123456789012345
2 -987654321098765
3 0

statement ok
DROP TABLE test_bigint_basic;


# Test Case 6/85
# 数值类型-BIGINT-边界测试最大值
# 测试BIGINT类型的最大值9223372036854775807

statement ok
DROP TABLE IF EXISTS test_bigint_max;


statement ok
CREATE TABLE test_bigint_max (id INT, col_bigint BIGINT);

statement ok
INSERT INTO test_bigint_max VALUES (1, 9223372036854775807);

query T
SELECT col_bigint FROM test_bigint_max;
----
9223372036854775807

statement ok
DROP TABLE test_bigint_max;


# Test Case 7/85
# 数值类型-BIGINT-边界测试最小值
# 测试BIGINT类型的最小值-9223372036854775808

statement ok
DROP TABLE IF EXISTS test_bigint_min;


statement ok
CREATE TABLE test_bigint_min (id INT, col_bigint BIGINT);

statement ok
INSERT INTO test_bigint_min VALUES (1, -9223372036854775808);

query T
SELECT col_bigint FROM test_bigint_min;
----
-9223372036854775808

statement ok
DROP TABLE test_bigint_min;


# Test Case 8/85
# 数值类型-SMALLINT-基本测试
# 测试SMALLINT类型的基本功能

statement ok
DROP TABLE IF EXISTS test_smallint_basic;


statement ok
CREATE TABLE test_smallint_basic (id INT, col_smallint SMALLINT);

statement ok
INSERT INTO test_smallint_basic VALUES (1, 12345), (2, -9876), (3, 0);

query TT
SELECT id, col_smallint FROM test_smallint_basic ORDER BY id;
----
1 12345
2 -9876
3 0

statement ok
DROP TABLE test_smallint_basic;


# Test Case 9/85
# 数值类型-SMALLINT-边界测试最大值
# 测试SMALLINT类型的最大值32767

statement ok
DROP TABLE IF EXISTS test_smallint_max;


statement ok
CREATE TABLE test_smallint_max (id INT, col_smallint SMALLINT);

statement ok
INSERT INTO test_smallint_max VALUES (1, 32767);

query T
SELECT col_smallint FROM test_smallint_max;
----
32767

statement ok
DROP TABLE test_smallint_max;


# Test Case 10/85
# 数值类型-SMALLINT-边界测试最小值
# 测试SMALLINT类型的最小值-32768

statement ok
DROP TABLE IF EXISTS test_smallint_min;


statement ok
CREATE TABLE test_smallint_min (id INT, col_smallint SMALLINT);

statement ok
INSERT INTO test_smallint_min VALUES (1, -32768);

query T
SELECT col_smallint FROM test_smallint_min;
----
-32768

statement ok
DROP TABLE test_smallint_min;


# Test Case 11/85
# 数值类型-SMALLINT-溢出测试
# 测试SMALLINT类型超出范围的错误处理

statement ok
DROP TABLE IF EXISTS test_smallint_overflow;


statement ok
CREATE TABLE test_smallint_overflow (id INT, col_smallint SMALLINT);

statement error
INSERT INTO test_smallint_overflow VALUES (1, 32768);

statement ok
DROP TABLE IF EXISTS test_smallint_overflow;


# Test Case 12/85
# 数值类型-TINYINT-基本测试
# 测试TINYINT类型的基本功能

statement ok
DROP TABLE IF EXISTS test_tinyint_basic;


statement ok
CREATE TABLE test_tinyint_basic (id INT, col_tinyint TINYINT);

statement ok
INSERT INTO test_tinyint_basic VALUES (1, 123), (2, -99), (3, 0);

query TT
SELECT id, col_tinyint FROM test_tinyint_basic ORDER BY id;
----
1 123
2 -99
3 0

statement ok
DROP TABLE test_tinyint_basic;


# Test Case 13/85
# 数值类型-TINYINT-边界测试最大值
# 测试TINYINT类型的最大值127

statement ok
DROP TABLE IF EXISTS test_tinyint_max;


statement ok
CREATE TABLE test_tinyint_max (id INT, col_tinyint TINYINT);

statement ok
INSERT INTO test_tinyint_max VALUES (1, 127);

query T
SELECT col_tinyint FROM test_tinyint_max;
----
127

statement ok
DROP TABLE test_tinyint_max;


# Test Case 14/85
# 数值类型-TINYINT-边界测试最小值
# 测试TINYINT类型的最小值-128

statement ok
DROP TABLE IF EXISTS test_tinyint_min;


statement ok
CREATE TABLE test_tinyint_min (id INT, col_tinyint TINYINT);

statement ok
INSERT INTO test_tinyint_min VALUES (1, -128);

query T
SELECT col_tinyint FROM test_tinyint_min;
----
-128

statement ok
DROP TABLE test_tinyint_min;


# Test Case 15/85
# 数值类型-DECIMAL-基本测试
# 测试DECIMAL类型的基本功能

statement ok
DROP TABLE IF EXISTS test_decimal_basic;

statement ok
CREATE TABLE test_decimal_basic (id INT, col_decimal DECIMAL(10,2));

statement ok
INSERT INTO test_decimal_basic VALUES (1, 12345.67), (2, -9876.54), (3, 0.00);

query TT
SELECT id, col_decimal FROM test_decimal_basic ORDER BY id;
----
1 12345.67
2 -9876.54
3 0

statement ok
DROP TABLE test_decimal_basic;


# Test Case 16/85
# 数值类型-DECIMAL-精度测试
# 测试DECIMAL类型的精度和标度

statement ok
DROP TABLE IF EXISTS test_decimal_precision;


statement ok
CREATE TABLE test_decimal_precision (id INT, col_decimal DECIMAL(15,4));

statement ok
INSERT INTO test_decimal_precision VALUES (1, 12345678901.2345), (2, -98765.4321);

query TT
SELECT id, col_decimal FROM test_decimal_precision ORDER BY id;
----
1 12345678901.2345
2 -98765.4321

statement ok
DROP TABLE test_decimal_precision;


# Test Case 17/85
# 数值类型-DECIMAL-最大精度测试
# 测试DECIMAL类型的最大精度38位

statement ok
DROP TABLE IF EXISTS test_decimal_max_precision;


statement ok
CREATE TABLE test_decimal_max_precision (id INT, col_decimal DECIMAL(38,0));

statement ok
INSERT INTO test_decimal_max_precision VALUES (1, 99999999999999999999999999999999999999);

query T
SELECT col_decimal FROM test_decimal_max_precision;
----
99999999999999999999999999999999999999

statement ok
DROP TABLE test_decimal_max_precision;


# Test Case 18/85
# 数值类型-DECIMAL-舍入测试
# 测试DECIMAL类型的数据舍入行为

statement ok
DROP TABLE IF EXISTS test_decimal_rounding;


statement ok
CREATE TABLE test_decimal_rounding (id INT, col_decimal DECIMAL(10,2));

statement ok
INSERT INTO test_decimal_rounding VALUES (1, 123.456), (2, 123.454);

query TT
SELECT id, col_decimal FROM test_decimal_rounding ORDER BY id;
----
1 123.46
2 123.45

statement ok
DROP TABLE test_decimal_rounding;


# Test Case 19/85
# 数值类型-NUMERIC-基本测试
# 测试NUMERIC类型的基本功能（与DECIMAL相同）

statement ok
DROP TABLE IF EXISTS test_numeric_basic;


statement ok
CREATE TABLE test_numeric_basic (id INT, col_numeric NUMERIC(12,3));

statement ok
INSERT INTO test_numeric_basic VALUES (1, 123456789.123), (2, -987654.321);

query TT
SELECT id, col_numeric FROM test_numeric_basic ORDER BY id;
----
1 123456789.123
2 -987654.321

statement ok
DROP TABLE test_numeric_basic;


# Test Case 20/85
# 数值类型-FLOAT-基本测试
# 测试FLOAT类型的基本功能

statement ok
DROP TABLE IF EXISTS test_float_basic;


statement ok
CREATE TABLE test_float_basic (id INT, col_float FLOAT);

statement ok
INSERT INTO test_float_basic VALUES (1, 123.456), (2, -987.654), (3, 0.0);

query TT
SELECT id, col_float FROM test_float_basic ORDER BY id;
----
1 1.23456E+002
2 -9.87654E+002
3 0

statement ok
DROP TABLE test_float_basic;


# Test Case 21/85
# 数值类型-FLOAT-精度测试
# 测试FLOAT类型指定精度

statement ok
DROP TABLE IF EXISTS test_float_precision;


statement ok
CREATE TABLE test_float_precision (id INT, col_float FLOAT(24));

statement ok
INSERT INTO test_float_precision VALUES (1, 1.23456789012345), (2, -9.87654321098765);

query TT
SELECT id, col_float FROM test_float_precision ORDER BY id;
----
1 1.2345679
2 -9.876543

statement ok
DROP TABLE test_float_precision;


# Test Case 22/85
# 数值类型-FLOAT-科学计数法测试
# 测试FLOAT类型的科学计数法表示

statement ok
DROP TABLE IF EXISTS test_float_scientific;


statement ok
CREATE TABLE test_float_scientific (id INT, col_float FLOAT);

statement ok
INSERT INTO test_float_scientific VALUES (1, 1.23E10), (2, -4.56E-5);

query TT
SELECT id, col_float FROM test_float_scientific ORDER BY id;
----
1 1.23E+010
2 -4.56E-005

statement ok
DROP TABLE test_float_scientific;


# Test Case 23/85
# 数值类型-DOUBLE-基本测试
# 测试DOUBLE类型的基本功能

statement ok
DROP TABLE IF EXISTS test_double_basic;


statement ok
CREATE TABLE test_double_basic (id INT, col_double DOUBLE);

statement ok
INSERT INTO test_double_basic VALUES (1, 123456.789012345), (2, -987654.321098765), (3, 0.0);

query TT
SELECT id, col_double FROM test_double_basic ORDER BY id;
----
1 1.23456789012345E+005
2 -9.87654321098765E+005
3 0

statement ok
DROP TABLE test_double_basic;


# Test Case 24/85
# 数值类型-DOUBLE-高精度测试
# 测试DOUBLE类型的高精度数值

statement ok
DROP TABLE IF EXISTS test_double_precision;


statement ok
CREATE TABLE test_double_precision (id INT, col_double DOUBLE);

statement ok
INSERT INTO test_double_precision VALUES (1, 1.7976931348623157E308), (2, 2.2250738585072014E-308);

query TT
SELECT id, col_double FROM test_double_precision ORDER BY id;
----
1 1.797693134862316E+308
2 2.225073858507201E-308

statement ok
DROP TABLE test_double_precision;


# Test Case 25/85
# 数值类型-REAL-基本测试
# 测试REAL类型的基本功能（等同于FLOAT）

statement ok
DROP TABLE IF EXISTS test_real_basic;


statement ok
CREATE TABLE test_real_basic (id INT, col_real REAL);

statement ok
INSERT INTO test_real_basic VALUES (1, 123.456), (2, -987.654);

query TT
SELECT id, col_real FROM test_real_basic ORDER BY id;
----
1 1.23456E+002
2 NULL

statement ok
DROP TABLE test_real_basic;


# Test Case 26/85
# 数值类型-NUMBER-基本测试
# 测试NUMBER类型的基本功能（达梦特有）

statement ok
DROP TABLE IF EXISTS test_number_basic;


statement ok
CREATE TABLE test_number_basic (id INT, col_number NUMBER(10,2));

statement ok
INSERT INTO test_number_basic VALUES (1, 12345.67), (2, -9876.54);

query TT
SELECT id, col_number FROM test_number_basic ORDER BY id;
----
1 12345.67
2 -9876.54

statement ok
DROP TABLE test_number_basic;


# Test Case 27/85
# 数值类型-NUMBER-无精度测试
# 测试NUMBER类型不指定精度的情况

statement ok
DROP TABLE IF EXISTS test_number_no_precision;


statement ok
CREATE TABLE test_number_no_precision (id INT, col_number NUMBER);

statement ok
INSERT INTO test_number_no_precision VALUES (1, 123456789.123456789), (2, -987654321.987654321);

query TT
SELECT id, CAST(col_number AS VARCHAR(50)) as col_number FROM test_number_no_precision ORDER BY id;
----
1 123456789.123456789
2 -987654321.987654321

statement ok
DROP TABLE test_number_no_precision;


# Test Case 28/85
# 数值类型-算术运算测试
# 测试数值类型的基本算术运算

statement ok
DROP TABLE IF EXISTS test_arithmetic;


statement ok
CREATE TABLE test_arithmetic (id INT, num1 INT, num2 INT, dec1 DECIMAL(10,2), dec2 DECIMAL(10,2));

statement ok
INSERT INTO test_arithmetic VALUES (1, 100, 25, 123.45, 67.89);

query TTTTTT
SELECT id, num1 + num2 as addition, num1 - num2 as subtraction, num1 * num2 as multiplication, num1 / num2 as division, dec1 + dec2 as decimal_add FROM test_arithmetic;
----
1 125 75 2500 4 191.34

statement ok
DROP TABLE test_arithmetic;


# Test Case 29/85
# 数值类型-比较运算测试
# 测试数值类型的比较运算

statement ok
DROP TABLE IF EXISTS test_comparison;


statement ok
CREATE TABLE test_comparison (id INT, value1 INT, value2 INT, dec_value DECIMAL(8,2));

statement ok
INSERT INTO test_comparison VALUES (1, 100, 50, 123.45), (2, 25, 75, 67.89), (3, 50, 50, 100.00);

query T
SELECT id FROM test_comparison WHERE value1 > value2 OR dec_value > 100 ORDER BY id;
----
1

statement ok
DROP TABLE test_comparison;


# Test Case 30/85
# 数值类型-聚合函数测试
# 测试数值类型的聚合函数

statement ok
DROP TABLE IF EXISTS test_aggregate;


statement ok
CREATE TABLE test_aggregate (id INT, value INT, price DECIMAL(10,2));

statement ok
INSERT INTO test_aggregate VALUES (1, 10, 123.45), (2, 20, 234.56), (3, 30, 345.67);

query TTTTT
SELECT COUNT(*) as count_all, SUM(value) as sum_value, AVG(price) as avg_price, MIN(value) as min_value, MAX(price) as max_price FROM test_aggregate;
----
3 60 234.56 10 345.67

statement ok
DROP TABLE test_aggregate;


# Test Case 31/85
# 数值类型-NULL值测试
# 测试数值类型的NULL值处理

statement ok
DROP TABLE IF EXISTS test_null_values;


statement ok
CREATE TABLE test_null_values (id INT, int_value INT, decimal_value DECIMAL(10,2), float_value FLOAT);

statement ok
INSERT INTO test_null_values VALUES (1, NULL, NULL, NULL), (2, 100, 123.45, 987.654);

query TTTT
SELECT id, int_value, decimal_value, float_value FROM test_null_values ORDER BY id;
----
1 NULL NULL NULL
2 100 123.45 9.87654E+002

statement ok
DROP TABLE test_null_values;


# Test Case 32/85
# 数值类型-零值除法测试
# 测试除零错误的处理

statement ok
DROP TABLE IF EXISTS test_division_by_zero;


statement ok
CREATE TABLE test_division_by_zero (id INT, value1 INT, value2 INT);

statement ok
INSERT INTO test_division_by_zero VALUES (1, 100, 0);

statement error
SELECT id, value1 / value2 as division FROM test_division_by_zero;

statement ok
DROP TABLE IF EXISTS test_division_by_zero;


# Test Case 33/85
# 数值类型-类型转换测试
# 测试数值类型之间的隐式转换

statement ok
DROP TABLE IF EXISTS test_type_conversion;


statement ok
CREATE TABLE test_type_conversion (id INT, int_col INT, float_col FLOAT, decimal_col DECIMAL(10,2));

statement ok
INSERT INTO test_type_conversion VALUES (1, 123, 123.456, 123);

query TTTT
SELECT id, int_col, float_col, decimal_col FROM test_type_conversion;
----
1 123 1.23456E+002 123

statement ok
DROP TABLE test_type_conversion;


# Test Case 34/85
# 数值类型-数学函数测试
# 测试常用数学函数与数值类型

statement ok
DROP TABLE IF EXISTS test_math_functions;


statement ok
CREATE TABLE test_math_functions (id INT, value DECIMAL(10,2));

statement ok
INSERT INTO test_math_functions VALUES (1, 16.25), (2, -9.75);

query TTTTT
SELECT id, ABS(value) as abs_value, ROUND(value, 1) as rounded_value, CEIL(value) as ceiling_value, FLOOR(value) as floor_value FROM test_math_functions ORDER BY id;
----
1 16.25 16.3 17 16
2 9.75 -9.8 -9 -10

statement ok
DROP TABLE test_math_functions;


# Test Case 35/85
# 数值类型-DOUBLE_PRECISION-基本测试
# 测试DOUBLE PRECISION类型的基本功能(双精度浮点数)

statement ok
DROP TABLE IF EXISTS test_double_precision_basic;


statement ok
CREATE TABLE test_double_precision_basic (id INT, col_double_precision DOUBLE PRECISION);

statement ok
INSERT INTO test_double_precision_basic VALUES (1, 123.456789012345), (2, -987.654321098765), (3, 0.0);

query TT
SELECT id, col_double_precision FROM test_double_precision_basic ORDER BY id;
----
1 1.23456789012345E+002
2 -9.87654321098765E+002
3 0

statement ok
DROP TABLE test_double_precision_basic;


# Test Case 36/85
# 数值类型-DOUBLE_PRECISION-精度测试
# 测试DOUBLE PRECISION类型指定精度

statement ok
DROP TABLE IF EXISTS test_double_precision_prec;


statement ok
CREATE TABLE test_double_precision_prec (id INT, col_double_precision DOUBLE PRECISION(53));

statement ok
INSERT INTO test_double_precision_prec VALUES (1, 1.23456789012345678901), (2, -9.87654321098765432109);

query TT
SELECT id, col_double_precision FROM test_double_precision_prec ORDER BY id;
----
1 1.2345678901234567
2 -9.876543210987654

statement ok
DROP TABLE test_double_precision_prec;


# Test Case 37/85
# 数值类型-DOUBLE_PRECISION-极值测试
# 测试DOUBLE PRECISION类型的取值范围

statement ok
DROP TABLE IF EXISTS test_double_precision_range;


statement ok
CREATE TABLE test_double_precision_range (id INT, col_double_precision DOUBLE PRECISION);

statement ok
INSERT INTO test_double_precision_range VALUES (1, 1.7976931348623157E+308), (2, -1.7976931348623157E+308), (3, 2.2250738585072014E-308);

query TT
SELECT id, col_double_precision FROM test_double_precision_range ORDER BY id;
----
1 1.797693134862316E+308
2 -1.797693134862316E+308
3 2.225073858507201E-308

statement ok
DROP TABLE test_double_precision_range;


# Test Case 38/85
# 数值类型-DOUBLE_PRECISION-科学计数法测试
# 测试DOUBLE PRECISION类型的科学计数法表示

statement ok
DROP TABLE IF EXISTS test_double_precision_scientific;


statement ok
CREATE TABLE test_double_precision_scientific (id INT, col_double_precision DOUBLE PRECISION);

statement ok
INSERT INTO test_double_precision_scientific VALUES (1, 1.23E+10), (2, 4.56E-15), (3, -7.89E+100);

query TT
SELECT id, col_double_precision FROM test_double_precision_scientific ORDER BY id;
----
1 1.23E+010
2 4.56E-015
3 -7.89e+100

statement ok
DROP TABLE test_double_precision_scientific;


# Test Case 39/85
# 数值类型-INT-负零测试
# 测试INT类型的负零处理

statement ok
DROP TABLE IF EXISTS test_int_negative_zero;


statement ok
CREATE TABLE test_int_negative_zero (id INT, col_int INT);

statement ok
INSERT INTO test_int_negative_zero VALUES (1, -0), (2, 0);

query TT
SELECT id, col_int FROM test_int_negative_zero ORDER BY id;
----
1 0
2 0

statement ok
DROP TABLE test_int_negative_zero;


# Test Case 40/85
# 数值类型-INT-下溢测试
# 测试INT类型超出最小范围的错误处理

statement ok
DROP TABLE IF EXISTS test_int_underflow;


statement ok
CREATE TABLE test_int_underflow (id BIGINT, col_int INT);

statement error
INSERT INTO test_int_underflow VALUES (1, -2147483649);

statement ok
DROP TABLE IF EXISTS test_int_underflow;


# Test Case 41/85
# 数值类型-BIGINT-溢出测试
# 测试BIGINT类型超出范围的错误处理

statement ok
DROP TABLE IF EXISTS test_bigint_overflow;


statement ok
CREATE TABLE test_bigint_overflow (id INT, col_bigint BIGINT);

statement error
INSERT INTO test_bigint_overflow VALUES (1, 9223372036854775808);

statement ok
DROP TABLE IF EXISTS test_bigint_overflow;


# Test Case 42/85
# 数值类型-BIGINT-下溢测试
# 测试BIGINT类型超出最小范围的错误处理

statement ok
DROP TABLE IF EXISTS test_bigint_underflow;


statement ok
CREATE TABLE test_bigint_underflow (id INT, col_bigint BIGINT);

statement error
INSERT INTO test_bigint_underflow VALUES (1, -9223372036854775809);

statement ok
DROP TABLE IF EXISTS test_bigint_underflow;


# Test Case 43/85
# 数值类型-SMALLINT-下溢测试
# 测试SMALLINT类型超出最小范围的错误处理

statement ok
DROP TABLE IF EXISTS test_smallint_underflow;


statement ok
CREATE TABLE test_smallint_underflow (id INT, col_smallint SMALLINT);

statement error
INSERT INTO test_smallint_underflow VALUES (1, -32769);

statement ok
DROP TABLE IF EXISTS test_smallint_underflow;


# Test Case 44/85
# 数值类型-TINYINT-溢出测试
# 测试TINYINT类型超出最大范围的错误处理

statement ok
DROP TABLE IF EXISTS test_tinyint_overflow;


statement ok
CREATE TABLE test_tinyint_overflow (id INT, col_tinyint TINYINT);

statement error
INSERT INTO test_tinyint_overflow VALUES (1, 128);

statement ok
DROP TABLE IF EXISTS test_tinyint_overflow;


# Test Case 45/85
# 数值类型-TINYINT-下溢测试
# 测试TINYINT类型超出最小范围的错误处理

statement ok
DROP TABLE IF EXISTS test_tinyint_underflow;


statement ok
CREATE TABLE test_tinyint_underflow (id INT, col_tinyint TINYINT);

statement error
INSERT INTO test_tinyint_underflow VALUES (1, -129);

statement ok
DROP TABLE IF EXISTS test_tinyint_underflow;


# Test Case 46/85
# 数值类型-DECIMAL-溢出测试
# 测试DECIMAL类型整数部分溢出的错误处理

statement ok
DROP TABLE IF EXISTS test_decimal_overflow;


statement ok
CREATE TABLE test_decimal_overflow (id INT, col_decimal DECIMAL(5,2));

statement error
INSERT INTO test_decimal_overflow VALUES (1, 9999.99);

statement ok
DROP TABLE IF EXISTS test_decimal_overflow;


# Test Case 47/85
# 数值类型-DECIMAL-最大整数部分测试
# 测试DECIMAL类型的最大整数部分边界

statement ok
DROP TABLE IF EXISTS test_decimal_max_int;


statement ok
CREATE TABLE test_decimal_max_int (id INT, col_decimal DECIMAL(5,2));

statement ok
INSERT INTO test_decimal_max_int VALUES (1, 999.99);

query T
SELECT col_decimal FROM test_decimal_max_int;
----
999.99

statement ok
DROP TABLE test_decimal_max_int;


# Test Case 48/85
# 数值类型-DECIMAL-零标度测试
# 测试DECIMAL类型标度为0的情况

statement ok
DROP TABLE IF EXISTS test_decimal_zero_scale;


statement ok
CREATE TABLE test_decimal_zero_scale (id INT, col_decimal DECIMAL(10,0));

statement ok
INSERT INTO test_decimal_zero_scale VALUES (1, 1234567890), (2, -9876543210);

query TT
SELECT id, col_decimal FROM test_decimal_zero_scale ORDER BY id;
----
1 1234567890
2 -9876543210

statement ok
DROP TABLE test_decimal_zero_scale;


# Test Case 49/85
# 数值类型-DECIMAL-最大标度测试
# 测试DECIMAL类型的最大标度

statement ok
DROP TABLE IF EXISTS test_decimal_max_scale;


statement ok
CREATE TABLE test_decimal_max_scale (id INT, col_decimal DECIMAL(38,30));

statement ok
INSERT INTO test_decimal_max_scale VALUES (1, 12345678.123456789012345678901234567890);

query T
SELECT col_decimal FROM test_decimal_max_scale;
----
12345678.12345678901234567890123456789

statement ok
DROP TABLE test_decimal_max_scale;


# Test Case 50/85
# 数值类型-DECIMAL-精度标度不匹配错误测试
# 测试DECIMAL类型标度大于精度的错误

statement error
statement ok
DROP TABLE IF EXISTS test_decimal_invalid_scale;


statement ok
CREATE TABLE test_decimal_invalid_scale (id INT, col_decimal DECIMAL(10,15));

statement ok
DROP TABLE IF EXISTS test_decimal_invalid_scale;


# Test Case 51/85
# 数值类型-FLOAT-零值测试
# 测试FLOAT类型的正零和负零

statement ok
DROP TABLE IF EXISTS test_float_zero;


statement ok
CREATE TABLE test_float_zero (id INT, col_float FLOAT);

statement ok
INSERT INTO test_float_zero VALUES (1, 0.0), (2, -0.0);

query TT
SELECT id, col_float FROM test_float_zero ORDER BY id;
----
1 0
2 0

statement ok
DROP TABLE test_float_zero;


# Test Case 52/85
# 数值类型-FLOAT-极小值测试
# 测试FLOAT类型的最小正值

statement ok
DROP TABLE IF EXISTS test_float_tiny;


statement ok
CREATE TABLE test_float_tiny (id INT, col_float FLOAT);

statement ok
INSERT INTO test_float_tiny VALUES (1, 1.175494e-38), (2, -1.175494e-38);

query TT
SELECT id, col_float FROM test_float_tiny ORDER BY id;
----
1 1.175494E-038
2 -1.175494E-038

statement ok
DROP TABLE test_float_tiny;


# Test Case 53/85
# 数值类型-FLOAT-精度边界测试
# 测试FLOAT类型的精度边界(1-53)

statement ok
DROP TABLE IF EXISTS test_float_precision_boundary;


statement ok
CREATE TABLE test_float_precision_boundary (id INT, float1 FLOAT(1), float53 FLOAT(53));

statement ok
INSERT INTO test_float_precision_boundary VALUES (1, 1.5, 1.23456789012345);

query TTT
SELECT id, float1, float53 FROM test_float_precision_boundary;
----
1 1.5 1.23456789012345

statement ok
DROP TABLE test_float_precision_boundary;


# Test Case 54/85
# 数值类型-FLOAT-无效精度错误测试
# 测试FLOAT类型精度超出范围的错误(FLOAT最大精度为126)

statement error
statement ok
DROP TABLE IF EXISTS test_float_invalid_precision;


statement error
CREATE TABLE test_float_invalid_precision (id INT, col_float FLOAT(128));

statement ok
DROP TABLE IF EXISTS test_float_invalid_precision;


# Test Case 55/85
# 数值类型-DOUBLE-零值测试
# 测试DOUBLE类型的正零和负零

statement ok
DROP TABLE IF EXISTS test_double_zero;


statement ok
CREATE TABLE test_double_zero (id INT, col_double DOUBLE);

statement ok
INSERT INTO test_double_zero VALUES (1, 0.0), (2, -0.0);

query TT
SELECT id, col_double FROM test_double_zero ORDER BY id;
----
1 0
2 0

statement ok
DROP TABLE test_double_zero;


# Test Case 56/85
# 数值类型-DOUBLE-极小值测试
# 测试DOUBLE类型的最小正值

statement ok
DROP TABLE IF EXISTS test_double_tiny;


statement ok
CREATE TABLE test_double_tiny (id INT, col_double DOUBLE);

statement ok
INSERT INTO test_double_tiny VALUES (1, 2.2250738585072014e-308), (2, -2.2250738585072014e-308);

query TT
SELECT id, col_double FROM test_double_tiny ORDER BY id;
----
1 2.2250738585072014E-308
2 -2.2250738585072014E-308

statement ok
DROP TABLE test_double_tiny;


# Test Case 57/85
# 数值类型-DOUBLE-极大值测试
# 测试DOUBLE类型的最大值

statement ok
DROP TABLE IF EXISTS test_double_max;


statement ok
CREATE TABLE test_double_max (id INT, col_double DOUBLE);

statement ok
INSERT INTO test_double_max VALUES (1, 1.7976931348623157e+308), (2, -1.7976931348623157e+308);

query TT
SELECT id, col_double FROM test_double_max ORDER BY id;
----
1 1.7976931348623157e+308
2 -1.7976931348623157e+308

statement ok
DROP TABLE test_double_max;


# Test Case 58/85
# 数值类型-类型转换-INT到BIGINT
# 测试INT到BIGINT的隐式类型转换

statement ok
DROP TABLE IF EXISTS test_int_to_bigint;


statement ok
CREATE TABLE test_int_to_bigint (id INT, int_col INT, bigint_col BIGINT);

statement ok
INSERT INTO test_int_to_bigint VALUES (1, 2147483647, 2147483647);

query TTT
SELECT id, int_col, bigint_col FROM test_int_to_bigint WHERE int_col = bigint_col;
----
1 2147483647 2147483647

statement ok
DROP TABLE test_int_to_bigint;


# Test Case 59/85
# 数值类型-类型转换-FLOAT到DOUBLE
# 测试FLOAT到DOUBLE的隐式类型转换

statement ok
DROP TABLE IF EXISTS test_float_to_double;


statement ok
CREATE TABLE test_float_to_double (id INT, float_col FLOAT, double_col DOUBLE);

statement ok
INSERT INTO test_float_to_double VALUES (1, 123.456, 123.456);

query TTT
SELECT id, float_col, double_col FROM test_float_to_double;
----
1 1.23456E+002 1.23456E+002

statement ok
DROP TABLE test_float_to_double;


# Test Case 60/85
# 数值类型-类型转换-INT到DECIMAL
# 测试INT到DECIMAL的隐式类型转换

statement ok
DROP TABLE IF EXISTS test_int_to_decimal;


statement ok
CREATE TABLE test_int_to_decimal (id INT, int_col INT, decimal_col DECIMAL(10,2));

statement ok
INSERT INTO test_int_to_decimal VALUES (1, 12345, 12345);

query TTT
SELECT id, int_col, decimal_col FROM test_int_to_decimal;
----
1 12345 12345

statement ok
DROP TABLE test_int_to_decimal;


# Test Case 61/85
# 数值类型-CAST转换-字符串到数字
# 测试字符串到数字类型的显式转换

statement ok
DROP TABLE IF EXISTS test_cast_string_to_num;


statement ok
CREATE TABLE test_cast_string_to_num (id INT, result_int INT, result_decimal DECIMAL(10,2));

statement ok
INSERT INTO test_cast_string_to_num VALUES (1, CAST('12345' AS INT), CAST('123.45' AS DECIMAL(10,2)));

query TTT
SELECT id, result_int, result_decimal FROM test_cast_string_to_num;
----
1 12345 123.45

statement ok
DROP TABLE test_cast_string_to_num;


# Test Case 62/85
# 数值类型-CAST转换错误-非法字符串
# 测试非法字符串转换为数字的错误

statement ok
DROP TABLE IF EXISTS test_cast_invalid_string;


statement ok
CREATE TABLE test_cast_invalid_string (id INT, num_col INT);

statement error
INSERT INTO test_cast_invalid_string VALUES (1, CAST('ABC' AS INT));

statement ok
DROP TABLE IF EXISTS test_cast_invalid_string;


# Test Case 63/85
# 数值类型-模运算测试
# 测试整数类型的模运算

statement ok
DROP TABLE IF EXISTS test_modulo;


statement ok
CREATE TABLE test_modulo (id INT, value1 INT, value2 INT);

statement ok
INSERT INTO test_modulo VALUES (1, 10, 3), (2, 100, 7), (3, 15, 5);

query TTTT
SELECT id, value1, value2, MOD(value1, value2) as mod_result FROM test_modulo ORDER BY id;
----
1 10 3 1
2 100 7 2
3 15 5 0

statement ok
DROP TABLE test_modulo;


# Test Case 64/85
# 数值类型-幂运算测试
# 测试数值类型的幂运算

statement ok
DROP TABLE IF EXISTS test_power;


statement ok
CREATE TABLE test_power (id INT, base_value DECIMAL(10,2), exponent INT);

statement ok
INSERT INTO test_power VALUES (1, 2, 3), (2, 10, 2), (3, 5, 0);

query TTTT
SELECT id, base_value, exponent, POWER(base_value, exponent) as power_result FROM test_power ORDER BY id;
----
1 2 3 8
2 10 2 1.0E+002
3 5 0 1

statement ok
DROP TABLE test_power;


# Test Case 65/85
# 数值类型-平方根函数测试
# 测试SQRT函数

statement ok
DROP TABLE IF EXISTS test_sqrt;


statement ok
CREATE TABLE test_sqrt (id INT, value DECIMAL(10,2));

statement ok
INSERT INTO test_sqrt VALUES (1, 16), (2, 25), (3, 100);

query TTT
SELECT id, value, SQRT(value) as sqrt_result FROM test_sqrt ORDER BY id;
----
1 16 4
2 25 5
3 100 1.0E+001

statement ok
DROP TABLE test_sqrt;


# Test Case 66/85
# 数值类型-平方根错误测试
# 测试负数平方根的错误

statement ok
DROP TABLE IF EXISTS test_sqrt_negative;


statement ok
CREATE TABLE test_sqrt_negative (id INT, value DECIMAL(10,2));

statement ok
INSERT INTO test_sqrt_negative VALUES (1, -16);

statement error
SELECT SQRT(value) FROM test_sqrt_negative;

statement ok
DROP TABLE IF EXISTS test_sqrt_negative;


# Test Case 67/85
# 数值类型-符号函数测试
# 测试SIGN函数返回数值的符号

statement ok
DROP TABLE IF EXISTS test_sign;


statement ok
CREATE TABLE test_sign (id INT, value DECIMAL(10,2));

statement ok
INSERT INTO test_sign VALUES (1, 100), (2, -100), (3, 0);

query TTT
SELECT id, value, SIGN(value) as sign_result FROM test_sign ORDER BY id;
----
1 100 1
2 -100 -1
3 0 0

statement ok
DROP TABLE test_sign;


# Test Case 68/85
# 数值类型-截断函数测试
# 测试TRUNC函数截断小数部分

statement ok
DROP TABLE IF EXISTS test_trunc;


statement ok
CREATE TABLE test_trunc (id INT, value DECIMAL(10,4));

statement ok
INSERT INTO test_trunc VALUES (1, 123.4567), (2, -98.7654), (3, 0.9999);

query TTTT
SELECT id, value, TRUNC(value, 2) as trunc_2, TRUNC(value, 0) as trunc_0 FROM test_trunc ORDER BY id;
----
1 123.4567 123.45 123
2 -98.7654 -98.76 -98
3 0.9999 0.99 0

statement ok
DROP TABLE test_trunc;


# Test Case 69/85
# 数值类型-三角函数测试
# 测试SIN, COS, TAN三角函数

statement ok
DROP TABLE IF EXISTS test_trig;


statement ok
CREATE TABLE test_trig (id INT, angle DOUBLE);

statement ok
INSERT INTO test_trig VALUES (1, 0), (2, 3.14159265358979/2);

query TTT
SELECT id, SIN(angle) as sin_val, COS(angle) as cos_val FROM test_trig ORDER BY id;
----
1 0 1
2 1.0 0.0

statement ok
DROP TABLE test_trig;


# Test Case 70/85
# 数值类型-对数函数测试
# 测试LOG和LN对数函数

statement ok
DROP TABLE IF EXISTS test_log;


statement ok
CREATE TABLE test_log (id INT, value DOUBLE);

statement ok
INSERT INTO test_log VALUES (1, 10), (2, 100), (3, 2.718281828);

query TTTT
SELECT id, value, LOG(10, value) as log10_val, LN(value) as ln_val FROM test_log ORDER BY id;
----
1 10.0 1.0 2.302585092994046
2 100.0 2.0 4.605170185988092
3 2.718281828 0.4342944819032518 1.0

statement ok
DROP TABLE test_log;


# Test Case 71/85
# 数值类型-GROUP BY聚合测试
# 测试GROUP BY与聚合函数的结合

statement ok
DROP TABLE IF EXISTS test_group_aggregate;


statement ok
CREATE TABLE test_group_aggregate (category VARCHAR(20), value INT, price DECIMAL(10,2));

statement ok
INSERT INTO test_group_aggregate VALUES ('A', 10, 100.50), ('A', 20, 200.75), ('B', 15, 150.25), ('B', 25, 250.00);

query TTT
SELECT category, SUM(value) as total_value, AVG(price) as avg_price FROM test_group_aggregate GROUP BY category ORDER BY category;
----
A 30 150.625
B 40 200.125

statement ok
DROP TABLE test_group_aggregate;


# Test Case 72/85
# 数值类型-HAVING子句测试
# 测试HAVING子句对聚合结果的过滤

statement ok
DROP TABLE IF EXISTS test_having;


statement ok
CREATE TABLE test_having (category VARCHAR(20), value INT);

statement ok
INSERT INTO test_having VALUES ('A', 10), ('A', 20), ('B', 5), ('B', 15), ('C', 30);

query TT
SELECT category, SUM(value) as total FROM test_having GROUP BY category HAVING SUM(value) > 20 ORDER BY category;
----
A 30
C 30

statement ok
DROP TABLE test_having;


# Test Case 73/85
# 数值类型-DISTINCT聚合测试
# 测试DISTINCT与聚合函数的结合

statement ok
DROP TABLE IF EXISTS test_distinct_aggregate;


statement ok
CREATE TABLE test_distinct_aggregate (id INT, value INT);

statement ok
INSERT INTO test_distinct_aggregate VALUES (1, 10), (2, 20), (3, 10), (4, 30), (5, 20);

query TTT
SELECT COUNT(value) as total_count, COUNT(DISTINCT value) as distinct_count, SUM(DISTINCT value) as distinct_sum FROM test_distinct_aggregate;
----
5 3 60

statement ok
DROP TABLE test_distinct_aggregate;


# Test Case 74/85
# 数值类型-CASE表达式测试
# 测试CASE表达式对数值的条件处理

statement ok
DROP TABLE IF EXISTS test_case_numeric;


statement ok
CREATE TABLE test_case_numeric (id INT, score INT);

statement ok
INSERT INTO test_case_numeric VALUES (1, 95), (2, 75), (3, 55), (4, 30);

query TTT
SELECT id, score, CASE WHEN score >= 90 THEN 'A' WHEN score >= 80 THEN 'B' WHEN score >= 70 THEN 'C' WHEN score >= 60 THEN 'D' ELSE 'F' END as grade FROM test_case_numeric ORDER BY id;
----
1 95 A
2 75 C
3 55 F
4 30 F

statement ok
DROP TABLE test_case_numeric;


# Test Case 75/85
# 数值类型-COALESCE函数测试
# 测试COALESCE函数处理NULL值

statement ok
DROP TABLE IF EXISTS test_coalesce;


statement ok
CREATE TABLE test_coalesce (id INT, value1 INT, value2 INT, value3 INT);

statement ok
INSERT INTO test_coalesce VALUES (1, NULL, NULL, 100), (2, NULL, 50, 100), (3, 10, 50, 100);

query TT
SELECT id, COALESCE(value1, value2, value3, 0) as result FROM test_coalesce ORDER BY id;
----
1 100
2 50
3 10

statement ok
DROP TABLE test_coalesce;


# Test Case 76/85
# 数值类型-NULLIF函数测试
# 测试NULLIF函数条件返回NULL

statement ok
DROP TABLE IF EXISTS test_nullif;


statement ok
CREATE TABLE test_nullif (id INT, value1 INT, value2 INT);

statement ok
INSERT INTO test_nullif VALUES (1, 10, 10), (2, 20, 30), (3, 0, 0);

query TTTT
SELECT id, value1, value2, NULLIF(value1, value2) as result FROM test_nullif ORDER BY id;
----
1 10 10 NULL
2 20 30 20
3 0 0 NULL

statement ok
DROP TABLE test_nullif;


# Test Case 77/85
# 数值类型-数值范围查询测试
# 测试数值类型的范围查询性能和正确性

statement ok
DROP TABLE IF EXISTS test_numeric_range;


statement ok
CREATE TABLE test_numeric_range (id INT, value INT);

statement ok
INSERT INTO test_numeric_range VALUES (1, 10), (2, 20), (3, 30), (4, 40), (5, 50), (6, 60), (7, 70), (8, 80), (9, 90), (10, 100);

query T
SELECT COUNT(*) as count FROM test_numeric_range WHERE value BETWEEN 30 AND 70;
----
5

statement ok
DROP TABLE test_numeric_range;


# Test Case 78/85
# 数值类型-IN操作符测试
# 测试IN操作符对数值类型的支持

statement ok
DROP TABLE IF EXISTS test_in_operator;


statement ok
CREATE TABLE test_in_operator (id INT, value INT);

statement ok
INSERT INTO test_in_operator VALUES (1, 10), (2, 20), (3, 30), (4, 40), (5, 50);

query TT
SELECT id, value FROM test_in_operator WHERE value IN (10, 30, 50) ORDER BY id;
----
1 10
3 30
5 50

statement ok
DROP TABLE test_in_operator;


# Test Case 79/85
# 数值类型-索引创建测试
# 测试数值类型列上的索引创建

statement ok
DROP TABLE IF EXISTS test_numeric_index;


statement ok
CREATE TABLE test_numeric_index (id INT PRIMARY KEY, value INT, price DECIMAL(10,2));

statement ok
CREATE INDEX idx_value ON test_numeric_index(value);

statement ok
CREATE INDEX idx_price ON test_numeric_index(price);

statement ok
INSERT INTO test_numeric_index VALUES (1, 100, 50.25), (2, 200, 75.50), (3, 150, 60.75);

query TT
SELECT id, value FROM test_numeric_index WHERE value > 100 ORDER BY value;
----
3 150
2 200

statement ok
DROP INDEX idx_price;

statement ok
DROP INDEX idx_value;

statement ok
DROP TABLE test_numeric_index;


# Test Case 80/85
# 数值类型-复合索引测试
# 测试多列数值类型的复合索引

statement ok
DROP TABLE IF EXISTS test_composite_index;


statement ok
CREATE TABLE test_composite_index (id INT PRIMARY KEY, category INT, value INT);

statement ok
CREATE INDEX idx_category_value ON test_composite_index(category, value);

statement ok
INSERT INTO test_composite_index VALUES (1, 1, 100), (2, 1, 200), (3, 2, 150), (4, 2, 250);

query TTT
SELECT id, category, value FROM test_composite_index WHERE category = 1 AND value > 150 ORDER BY value;
----
2 1 200

statement ok
DROP INDEX idx_category_value;

statement ok
DROP TABLE test_composite_index;


# Test Case 81/85
# 数值类型-唯一约束测试
# 测试数值类型列的唯一约束

statement ok
DROP TABLE IF EXISTS test_unique_constraint;


statement ok
CREATE TABLE test_unique_constraint (id INT PRIMARY KEY, unique_value INT UNIQUE);

statement ok
INSERT INTO test_unique_constraint VALUES (1, 100), (2, 200);

statement error
INSERT INTO test_unique_constraint VALUES (3, 100);

statement ok
DROP TABLE IF EXISTS test_unique_constraint;


# Test Case 82/85
# 数值类型-CHECK约束测试
# 测试数值类型的CHECK约束

statement ok
DROP TABLE IF EXISTS test_check_constraint;


statement ok
CREATE TABLE test_check_constraint (id INT PRIMARY KEY, age INT CHECK (age >= 0 AND age <= 150));

statement ok
INSERT INTO test_check_constraint VALUES (1, 25);

statement error
INSERT INTO test_check_constraint VALUES (2, 200);

statement ok
DROP TABLE IF EXISTS test_check_constraint;


# Test Case 83/85
# 数值类型-DEFAULT约束测试
# 测试数值类型的DEFAULT约束

statement ok
DROP TABLE IF EXISTS test_default_constraint;


statement ok
CREATE TABLE test_default_constraint (id INT PRIMARY KEY, value INT DEFAULT 100, price DECIMAL(10,2) DEFAULT 50.00);

statement ok
INSERT INTO test_default_constraint (id) VALUES (1), (2);

query TTT
SELECT id, value, price FROM test_default_constraint ORDER BY id;
----
1 100 50
2 100 50

statement ok
DROP TABLE test_default_constraint;


# Test Case 84/85
# 数值类型-自增列测试
# 测试数值类型的自增列(IDENTITY)

statement ok
DROP TABLE IF EXISTS test_identity;


statement ok
CREATE TABLE test_identity (id INT IDENTITY(1,1) PRIMARY KEY, value VARCHAR(20));

statement ok
INSERT INTO test_identity (value) VALUES ('First'), ('Second'), ('Third');

query TT
SELECT id, value FROM test_identity ORDER BY id;
----
1 First
2 Second
3 Third

statement ok
DROP TABLE test_identity;


# Test Case 85/85
# 数值类型-序列生成器测试
# 测试使用序列生成数值

statement ok
CREATE SEQUENCE test_seq START WITH 1 INCREMENT BY 1;

statement ok
DROP TABLE IF EXISTS test_sequence;


statement ok
CREATE TABLE test_sequence (id INT PRIMARY KEY, seq_value INT);

statement ok
INSERT INTO test_sequence VALUES (1, test_seq.NEXTVAL), (2, test_seq.NEXTVAL), (3, test_seq.NEXTVAL);

query TT
SELECT id, seq_value FROM test_sequence ORDER BY id;
----
1 1
2 2
3 3

statement ok
DROP TABLE test_sequence;

statement ok
DROP SEQUENCE test_seq;
