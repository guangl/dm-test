# Generated from datatypes_binary_tests.json
# Total test cases: 36

# Test Case 1/36
# 二进制类型-BINARY-边界值测试-空值
# 测试BINARY类型的空二进制值(0x)

statement ok
DROP TABLE IF EXISTS test_binary_empty;


statement ok
CREATE TABLE test_binary_empty (id INT, col_binary BINARY(10));

statement error
INSERT INTO test_binary_empty VALUES (1, 0x);

statement ok
DROP TABLE test_binary_empty;


# Test Case 2/36
# 二进制类型-BINARY-全0测试
# 测试BINARY类型存储全0字节

statement ok
DROP TABLE IF EXISTS test_binary_zeros;

statement ok
CREATE TABLE test_binary_zeros (id INT, col_binary BINARY(10));

statement ok
INSERT INTO test_binary_zeros VALUES (1, 0x00000000000000000000), (2, 0x0000000000);

query TT
SELECT id, LENGTHB(col_binary) AS bin_length FROM test_binary_zeros ORDER BY id;
----
1 10
2 10

statement ok
DROP TABLE test_binary_zeros;


# Test Case 3/36
# 二进制类型-BINARY-全FF测试
# 测试BINARY类型存储全FF字节

statement ok
DROP TABLE IF EXISTS test_binary_ff;


statement ok
CREATE TABLE test_binary_ff (id INT, col_binary BINARY(5));

statement ok
INSERT INTO test_binary_ff VALUES (1, 0xFFFFFFFFFF), (2, 0xFF);

query TTT
SELECT id, col_binary, LENGTHB(col_binary) AS bin_length FROM test_binary_ff ORDER BY id;
----
1 ffffffffff 5
2 ff00000000 5

statement ok
DROP TABLE test_binary_ff;


# Test Case 4/36
# 二进制类型-BINARY-长度溢出测试
# 测试插入超过定义长度的二进制数据

statement ok
DROP TABLE IF EXISTS test_binary_overflow;


statement ok
CREATE TABLE test_binary_overflow (id INT, col_binary BINARY(5));

statement error
INSERT INTO test_binary_overflow VALUES (1, 0x112233445566778899);

statement ok
DROP TABLE test_binary_overflow;


# Test Case 5/36
# 二进制类型-BINARY-自动填充测试
# 测试BINARY类型自动用0填充到定义长度

statement ok
DROP TABLE IF EXISTS test_binary_padding;


statement ok
CREATE TABLE test_binary_padding (id INT, col_binary BINARY(10));

statement ok
INSERT INTO test_binary_padding VALUES (1, 0x11), (2, 0x1122), (3, 0x112233);

query TT
SELECT id, LENGTHB(col_binary) AS actual_length FROM test_binary_padding ORDER BY id;
----
1 10
2 10
3 10

statement ok
DROP TABLE test_binary_padding;


# Test Case 6/36
# 二进制类型-VARBINARY-最小长度1测试
# 测试VARBINARY类型的最小长度1字节

statement ok
DROP TABLE IF EXISTS test_varbinary_min;


statement ok
CREATE TABLE test_varbinary_min (id INT, col_varbinary VARBINARY(1));

statement ok
INSERT INTO test_varbinary_min VALUES (1, 0x00), (2, 0xFF);

query TT
SELECT * FROM test_varbinary_min ORDER BY id;
----
1 00
2 ff

statement ok
DROP TABLE test_varbinary_min;


# Test Case 7/36
# 二进制类型-VARBINARY-空字符串测试
# 测试VARBINARY类型存储空二进制串

statement ok
DROP TABLE IF EXISTS test_varbinary_empty;


statement ok
CREATE TABLE test_varbinary_empty (id INT, col_varbinary VARBINARY(100));

statement error
INSERT INTO test_varbinary_empty VALUES (1, 0x);

statement ok
DROP TABLE test_varbinary_empty;


# Test Case 8/36
# 二进制类型-VARBINARY-长度溢出测试
# 测试VARBINARY类型插入超过定义长度的数据

statement ok
DROP TABLE IF EXISTS test_varbinary_overflow;


statement ok
CREATE TABLE test_varbinary_overflow (id INT, col_varbinary VARBINARY(10));

statement error
INSERT INTO test_varbinary_overflow VALUES (1, 0x11223344556677889900AABBCCDD);

statement ok
DROP TABLE test_varbinary_overflow;


# Test Case 9/36
# 二进制类型-VARBINARY-不填充测试
# 测试VARBINARY类型不自动填充,只占用实际长度

statement ok
DROP TABLE IF EXISTS test_varbinary_nopadding;


statement ok
CREATE TABLE test_varbinary_nopadding (id INT, col_varbinary VARBINARY(100));

statement ok
INSERT INTO test_varbinary_nopadding VALUES (1, 0x11), (2, 0x1122), (3, 0x112233), (4, 0x11223344);

query TT
SELECT id, LENGTHB(col_varbinary) AS actual_length FROM test_varbinary_nopadding ORDER BY id;
----
1 1
2 2
3 3
4 4

statement ok
DROP TABLE test_varbinary_nopadding;


# Test Case 10/36
# 二进制类型-RAW-最大长度测试
# 测试RAW类型的最大长度32767字节

statement ok
DROP TABLE IF EXISTS test_raw_maxlen;


statement ok
CREATE TABLE test_raw_maxlen (id INT, col_raw RAW(32767));

statement ok
INSERT INTO test_raw_maxlen VALUES (1, 0x48656C6C6F);

query TT
SELECT id, LENGTHB(col_raw) AS raw_length FROM test_raw_maxlen;
----
1 5

statement ok
DROP TABLE test_raw_maxlen;


# Test Case 11/36
# 二进制类型-RAW-HEXTORAW函数测试
# 测试HEXTORAW函数将十六进制字符串转换为RAW

statement ok
DROP TABLE IF EXISTS test_hextoraw;


statement ok
CREATE TABLE test_hextoraw (id INT, col_raw RAW(50));

statement ok
INSERT INTO test_hextoraw VALUES (1, HEXTORAW('48656C6C6F')), (2, HEXTORAW('576F726C64'));

query TT
SELECT id, LENGTHB(col_raw) AS raw_length FROM test_hextoraw ORDER BY id;
----
1 5
2 5

statement ok
DROP TABLE test_hextoraw;


# Test Case 12/36
# 二进制类型-RAW-RAWTOHEX函数测试
# 测试RAWTOHEX函数将RAW转换为十六进制字符串

statement ok
DROP TABLE IF EXISTS test_rawtohex;


statement ok
CREATE TABLE test_rawtohex (id INT, col_raw RAW(50));

statement ok
INSERT INTO test_rawtohex VALUES (1, 0x48656C6C6F), (2, 0x576F726C64);

query TT
SELECT id, RAWTOHEX(col_raw) AS hex_string FROM test_rawtohex ORDER BY id;
----
1 48656C6C6F
2 576F726C64

statement ok
DROP TABLE test_rawtohex;


# Test Case 13/36
# 二进制函数-LENGTHB长度测试
# 测试LENGTHB函数获取二进制数据字节长度

statement ok
DROP TABLE IF EXISTS test_lengthb;


statement ok
CREATE TABLE test_lengthb (id INT, col_binary BINARY(20), col_varbinary VARBINARY(20));

statement ok
INSERT INTO test_lengthb VALUES (1, 0x48656C6C6F, 0x48656C6C6F), (2, 0x1122334455, 0x1122334455);

query TTT
SELECT id, LENGTHB(col_binary) AS binary_len, LENGTHB(col_varbinary) AS varbinary_len FROM test_lengthb ORDER BY id;
----
1 20 5
2 20 5

statement ok
DROP TABLE test_lengthb;


# Test Case 14/36
# 二进制函数-SUBSTR子串提取测试
# 测试SUBSTR函数提取二进制子串

statement ok
DROP TABLE IF EXISTS test_binary_substr;


statement ok
CREATE TABLE test_binary_substr (id INT, col_varbinary VARBINARY(50));

statement ok
INSERT INTO test_binary_substr VALUES (1, 0x48656C6C6F576F726C64);

query TTT
SELECT id, SUBSTR(col_varbinary, 1, 5) AS first_5bytes, SUBSTR(col_varbinary, 6, 5) AS next_5bytes FROM test_binary_substr;
----
1 48656 C6C6F

statement ok
DROP TABLE test_binary_substr;


# Test Case 15/36
# 二进制函数-CONCAT拼接测试
# 测试CONCAT函数拼接二进制数据

statement ok
DROP TABLE IF EXISTS test_binary_concat;


statement ok
CREATE TABLE test_binary_concat (id INT, bin1 VARBINARY(20), bin2 VARBINARY(20));

statement ok
INSERT INTO test_binary_concat VALUES (1, 0x48656C6C6F, 0x576F726C64);

query TTTT
SELECT id, LENGTHB(bin1) AS len1, LENGTHB(bin2) AS len2, LENGTHB(bin1 || bin2) AS concat_len FROM test_binary_concat;
----
1 5 5 10

statement ok
DROP TABLE test_binary_concat;


# Test Case 16/36
# 二进制类型-与字符类型转换-TO_CHAR
# 测试二进制数据转换为字符类型

statement ok
DROP TABLE IF EXISTS test_binary_to_char;


statement ok
CREATE TABLE test_binary_to_char (id INT, col_varbinary VARBINARY(50));

statement ok
INSERT INTO test_binary_to_char VALUES (1, 0x48656C6C6F);

query TT
SELECT id, RAWTOHEX(col_varbinary) AS hex_str FROM test_binary_to_char;
----
1 48656C6C6F

statement ok
DROP TABLE test_binary_to_char;


# Test Case 17/36
# 二进制类型-与数值类型转换
# 测试二进制数据与数值类型的转换

statement ok
DROP TABLE IF EXISTS test_binary_number;


statement ok
CREATE TABLE test_binary_number (id INT, num_value INT, bin_value VARBINARY(20));

statement ok
INSERT INTO test_binary_number VALUES (1, 255, 0xFF), (2, 65535, 0xFFFF);

query TTT
SELECT id, num_value, LENGTHB(bin_value) AS bin_length FROM test_binary_number ORDER BY id;
----
1 255 1
2 65535 2

statement ok
DROP TABLE test_binary_number;


# Test Case 18/36
# 二进制类型-BLOB类型基本测试
# 测试BLOB大对象类型的基本功能

statement ok
DROP TABLE IF EXISTS test_blob_basic;


statement ok
CREATE TABLE test_blob_basic (id INT, col_blob BLOB);

statement ok
INSERT INTO test_blob_basic VALUES (1, 0x48656C6C6F576F726C64), (2, 0x4461746162617365);

query TT
SELECT id, LENGTHB(col_blob) AS blob_length FROM test_blob_basic ORDER BY id;
----
1 10
2 8

statement ok
DROP TABLE test_blob_basic;


# Test Case 19/36
# 二进制类型-BLOB大数据测试
# 测试BLOB类型存储大量二进制数据

statement ok
DROP TABLE IF EXISTS test_blob_large;


statement ok
CREATE TABLE test_blob_large (id INT, col_blob BLOB);

query T
SELECT COUNT(*) AS count FROM test_blob_large;
----
0

statement ok
DROP TABLE test_blob_large;


# Test Case 20/36
# 二进制类型-IMAGE类型基本测试
# 测试IMAGE类型的基本功能(等同于BLOB)

statement ok
DROP TABLE IF EXISTS test_image_basic;


statement ok
CREATE TABLE test_image_basic (id INT, col_image IMAGE);

statement ok
INSERT INTO test_image_basic VALUES (1, 0x89504E470D0A1A0A);

query TT
SELECT id, LENGTHB(col_image) AS image_length FROM test_image_basic;
----
1 8

statement ok
DROP TABLE test_image_basic;


# Test Case 21/36
# 二进制类型-LONGVARBINARY类型测试
# 测试LONGVARBINARY类型存储长二进制数据

statement ok
DROP TABLE IF EXISTS test_longvarbinary;


statement ok
CREATE TABLE test_longvarbinary (id INT, col_longvarbinary LONGVARBINARY);

statement ok
INSERT INTO test_longvarbinary VALUES (1, 0x48656C6C6F576F726C64);

query TT
SELECT id, LENGTHB(col_longvarbinary) AS length FROM test_longvarbinary;
----
1 10

statement ok
DROP TABLE test_longvarbinary;


# Test Case 22/36
# 二进制类型-NULL值与空串区分
# 测试二进制类型的NULL值与空串的区别

statement ok
DROP TABLE IF EXISTS test_binary_null_empty;


statement ok
CREATE TABLE test_binary_null_empty (id INT, col_varbinary VARBINARY(50));

statement ok
INSERT INTO test_binary_null_empty VALUES (1, NULL), (2, 0x00);

query TTT
SELECT id, CASE WHEN col_varbinary IS NULL THEN 'NULL' ELSE 'NOT NULL' END AS null_check, LENGTHB(col_varbinary) AS length FROM test_binary_null_empty ORDER BY id;
----
1 NULL NULL
2 NOT NULL 1

statement ok
DROP TABLE test_binary_null_empty;


# Test Case 23/36
# 二进制类型-BINARY与VARBINARY比较
# 测试BINARY和VARBINARY类型的存储差异

statement ok
DROP TABLE IF EXISTS test_binary_varbinary_compare;


statement ok
CREATE TABLE test_binary_varbinary_compare (id INT, col_binary BINARY(10), col_varbinary VARBINARY(10));

statement ok
INSERT INTO test_binary_varbinary_compare VALUES (1, 0x48656C6C6F, 0x48656C6C6F), (2, 0x11, 0x11);

query TTT
SELECT id, LENGTHB(col_binary) AS binary_len, LENGTHB(col_varbinary) AS varbinary_len FROM test_binary_varbinary_compare ORDER BY id;
----
1 10 5
2 10 1

statement ok
DROP TABLE test_binary_varbinary_compare;


# Test Case 24/36
# 二进制类型-复合索引测试
# 测试在二进制列上创建复合索引

statement ok
DROP TABLE IF EXISTS test_binary_compound_index;


statement ok
CREATE TABLE test_binary_compound_index (id INT PRIMARY KEY, category INT, data VARBINARY(50));

statement ok
CREATE INDEX idx_category_data ON test_binary_compound_index(category, data);

statement ok
INSERT INTO test_binary_compound_index VALUES (1, 1, 0x48656C6C6F), (2, 1, 0x576F726C64), (3, 2, 0x48656C6C6F);

query T
SELECT COUNT(*) AS count FROM test_binary_compound_index WHERE category = 1;
----
2

statement ok
DROP INDEX idx_category_data;

statement ok
DROP TABLE test_binary_compound_index;


# Test Case 25/36
# 二进制类型-唯一性约束测试
# 测试二进制列的唯一性约束

statement ok
DROP TABLE IF EXISTS test_binary_unique;


statement ok
CREATE TABLE test_binary_unique (id INT PRIMARY KEY, unique_data VARBINARY(50) UNIQUE);

statement ok
INSERT INTO test_binary_unique VALUES (1, 0x48656C6C6F), (2, 0x576F726C64);

query T
SELECT COUNT(*) AS count FROM test_binary_unique;
----
2

statement ok
DROP TABLE test_binary_unique;


# Test Case 26/36
# 二进制类型-唯一性约束违反测试
# 测试插入重复二进制值时的唯一性约束违反

statement ok
DROP TABLE IF EXISTS test_binary_unique_violation;


statement ok
CREATE TABLE test_binary_unique_violation (id INT PRIMARY KEY, unique_data VARBINARY(50) UNIQUE);

statement ok
INSERT INTO test_binary_unique_violation VALUES (1, 0x48656C6C6F);

statement error
INSERT INTO test_binary_unique_violation VALUES (2, 0x48656C6C6F);

statement ok
DROP TABLE test_binary_unique_violation;


# Test Case 27/36
# 二进制类型-DEFAULT值测试
# 测试二进制列的默认值设置

statement ok
DROP TABLE IF EXISTS test_binary_default;


statement ok
CREATE TABLE test_binary_default (id INT, col_varbinary VARBINARY(20) DEFAULT 0x00);

statement ok
INSERT INTO test_binary_default (id) VALUES (1);

query TT
SELECT id, LENGTHB(col_varbinary) AS length FROM test_binary_default;
----
1 1

statement ok
DROP TABLE test_binary_default;


# Test Case 28/36
# 二进制类型-ORDER BY排序测试
# 测试二进制数据的排序(按字节值排序)

statement ok
DROP TABLE IF EXISTS test_binary_order;


statement ok
CREATE TABLE test_binary_order (id INT, col_varbinary VARBINARY(20));

statement ok
INSERT INTO test_binary_order VALUES (1, 0xFF), (2, 0x00), (3, 0x7F), (4, 0x80);

query T
SELECT id FROM test_binary_order ORDER BY col_varbinary;
----
2
3
4
1

statement ok
DROP TABLE test_binary_order;


# Test Case 29/36
# 二进制类型-聚合函数COUNT测试
# 测试二进制类型与COUNT聚合函数

statement ok
DROP TABLE IF EXISTS test_binary_count;


statement ok
CREATE TABLE test_binary_count (id INT, data VARBINARY(50));

statement ok
INSERT INTO test_binary_count VALUES (1, 0x11), (2, NULL), (3, 0x22), (4, NULL), (5, 0x33);

query TTT
SELECT COUNT(*) AS total_count, COUNT(data) AS non_null_count, COUNT(DISTINCT data) AS distinct_count FROM test_binary_count;
----
5 3 3

statement ok
DROP TABLE test_binary_count;


# Test Case 30/36
# 二进制类型-GROUP BY分组测试
# 测试二进制列的GROUP BY分组

statement ok
DROP TABLE IF EXISTS test_binary_groupby;


statement ok
CREATE TABLE test_binary_groupby (id INT, category VARBINARY(10), value INT);

statement ok
INSERT INTO test_binary_groupby VALUES (1, 0x01, 100), (2, 0x01, 200), (3, 0x02, 150), (4, 0x02, 250);

query TT
SELECT category, SUM(value) AS total_value FROM test_binary_groupby GROUP BY category ORDER BY category;
----
01 300
02 400

statement ok
DROP TABLE test_binary_groupby;


# Test Case 31/36
# 二进制类型-JOIN连接测试
# 测试基于二进制列的表连接

statement ok
DROP TABLE IF EXISTS test_binary_join1;


statement ok
CREATE TABLE test_binary_join1 (id INT, key_data VARBINARY(20), value1 VARCHAR(50));

statement ok
DROP TABLE IF EXISTS test_binary_join2;


statement ok
CREATE TABLE test_binary_join2 (id INT, key_data VARBINARY(20), value2 VARCHAR(50));

statement ok
INSERT INTO test_binary_join1 VALUES (1, 0x11, 'A'), (2, 0x22, 'B');

statement ok
INSERT INTO test_binary_join2 VALUES (1, 0x11, 'X'), (2, 0x22, 'Y');

query TTT
SELECT t1.id, t1.value1, t2.value2 FROM test_binary_join1 t1 JOIN test_binary_join2 t2 ON t1.key_data = t2.key_data ORDER BY t1.id;
----
1 A X
2 B Y

statement ok
DROP TABLE test_binary_join1;

statement ok
DROP TABLE test_binary_join2;


# Test Case 32/36
# 二进制类型-CASE表达式测试
# 测试二进制列在CASE表达式中的使用

statement ok
DROP TABLE IF EXISTS test_binary_case;


statement ok
CREATE TABLE test_binary_case (id INT, flag VARBINARY(1), description VARCHAR(50));

statement ok
INSERT INTO test_binary_case VALUES (1, 0x00, 'Zero'), (2, 0x01, 'One'), (3, 0xFF, 'Max');

query TT
SELECT id, CASE WHEN flag = 0x00 THEN 'ZERO' WHEN flag = 0x01 THEN 'ONE' ELSE 'OTHER' END AS flag_desc FROM test_binary_case ORDER BY id;
----
1 ZERO
2 ONE
3 OTHER

statement ok
DROP TABLE test_binary_case;


# Test Case 33/36
# 二进制类型-UPDATE更新测试
# 测试更新二进制列的值

statement ok
DROP TABLE IF EXISTS test_binary_update;


statement ok
CREATE TABLE test_binary_update (id INT, data VARBINARY(50));

statement ok
INSERT INTO test_binary_update VALUES (1, 0x11), (2, 0x22);

statement ok
UPDATE test_binary_update SET data = 0xFFFF WHERE id = 1;

query TT
SELECT id, data FROM test_binary_update ORDER BY id;
----
1 ffff
2 22

statement ok
DROP TABLE test_binary_update;


# Test Case 34/36
# 二进制类型-DELETE删除测试
# 测试基于二进制列条件删除数据

statement ok
DROP TABLE IF EXISTS test_binary_delete;


statement ok
CREATE TABLE test_binary_delete (id INT, data VARBINARY(50));

statement ok
INSERT INTO test_binary_delete VALUES (1, 0x11), (2, 0x22), (3, 0x33);

statement ok
DELETE FROM test_binary_delete WHERE data = 0x22;

query T
SELECT COUNT(*) AS count FROM test_binary_delete;
----
2

statement ok
DROP TABLE test_binary_delete;


# Test Case 35/36
# 二进制类型-事务回滚测试
# 测试二进制数据的事务回滚

statement ok
DROP TABLE IF EXISTS test_binary_transaction;


statement ok
CREATE TABLE test_binary_transaction (id INT, data VARBINARY(50));

statement ok
INSERT INTO test_binary_transaction VALUES (1, 0x11);

query T
SELECT COUNT(*) AS count FROM test_binary_transaction;
----
1

statement ok
DROP TABLE test_binary_transaction;


# Test Case 36/36
# 性能测试-大量二进制数据插入
# 测试批量插入二进制数据的性能

statement ok
DROP TABLE IF EXISTS test_binary_bulk_insert;


statement ok
CREATE TABLE test_binary_bulk_insert (id INT, data VARBINARY(100));

statement ok
INSERT INTO test_binary_bulk_insert SELECT ROWNUM, 0x48656C6C6F576F726C64 FROM DUAL CONNECT BY ROWNUM <= 1000;

query T
SELECT COUNT(*) AS total_count FROM test_binary_bulk_insert;
----
1000

statement ok
DROP TABLE test_binary_bulk_insert;
