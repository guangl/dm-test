# Generated from datatypes_character_tests.json
# Total test cases: 32

# Test Case 1/32
# 字符类型-CHAR-空字符串与NULL对比测试
# 测试CHAR类型空字符串与NULL的区别

statement ok
DROP TABLE IF EXISTS test_char_empty_vs_null;


statement ok
CREATE TABLE test_char_empty_vs_null (id INT, col_empty CHAR(10), col_null CHAR(10));

statement ok
INSERT INTO test_char_empty_vs_null VALUES (1, '', NULL);

query TTT
SELECT id, CASE WHEN col_empty IS NULL THEN 'NULL' ELSE 'NOT_NULL' END as empty_check, CASE WHEN col_null IS NULL THEN 'NULL' ELSE 'NOT_NULL' END as null_check FROM test_char_empty_vs_null;
----
1 NOT_NULL NULL

statement ok
DROP TABLE test_char_empty_vs_null;


# Test Case 2/32
# 字符类型-CHAR-零长度错误测试
# 测试CHAR类型长度为0的错误

statement error
statement ok
DROP TABLE IF EXISTS test_char_zero_length;


statement error
CREATE TABLE test_char_zero_length (id INT, col_char CHAR(0));

statement ok
DROP TABLE IF EXISTS test_char_zero_length;


# Test Case 3/32
# 字符类型-CHAR-大小写敏感测试
# 测试CHAR类型的大小写敏感性

statement ok
DROP TABLE IF EXISTS test_char_case_sensitive;


statement ok
CREATE TABLE test_char_case_sensitive (id INT, col_char CHAR(10));

statement ok
INSERT INTO test_char_case_sensitive VALUES (1, 'ABC'), (2, 'abc'), (3, 'AbC');

query T
SELECT COUNT(DISTINCT col_char) as distinct_count FROM test_char_case_sensitive;
----
3

statement ok
DROP TABLE test_char_case_sensitive;


# Test Case 4/32
# 字符类型-CHAR-尾部空格保留测试
# 测试CHAR类型对尾部空格的保留行为

statement ok
DROP TABLE IF EXISTS test_char_trailing_spaces;


statement ok
CREATE TABLE test_char_trailing_spaces (id INT, col_char CHAR(10));

statement ok
INSERT INTO test_char_trailing_spaces VALUES (1, 'ABC');

query TT
SELECT LENGTHB(col_char) as char_length, LENGTHB(RTRIM(col_char)) as trimmed_length FROM test_char_trailing_spaces;
----
10 3

statement ok
DROP TABLE test_char_trailing_spaces;


# Test Case 5/32
# 字符类型-VARCHAR-最大长度插入测试
# 测试VARCHAR类型插入最大长度字符串

statement ok
DROP TABLE IF EXISTS test_varchar_max_insert;


statement ok
CREATE TABLE test_varchar_max_insert (id INT, col_varchar VARCHAR(100));

statement ok
INSERT INTO test_varchar_max_insert VALUES (1, RPAD('A', 100, 'B'));

query TT
SELECT id, LENGTHB(col_varchar) as varchar_length FROM test_varchar_max_insert;
----
1 100

statement ok
DROP TABLE test_varchar_max_insert;


# Test Case 6/32
# 字符类型-VARCHAR-超长插入错误测试
# 测试VARCHAR类型插入超长字符串报错

statement ok
DROP TABLE IF EXISTS test_varchar_overlong;


statement ok
CREATE TABLE test_varchar_overlong (id INT, col_varchar VARCHAR(10));

statement error
INSERT INTO test_varchar_overlong VALUES (1, RPAD('A', 100, 'B'));

statement ok
DROP TABLE test_varchar_overlong;


# Test Case 7/32
# 字符类型-VARCHAR-尾部空格不填充测试
# 测试VARCHAR类型不填充尾部空格

statement ok
DROP TABLE IF EXISTS test_varchar_no_padding;


statement ok
CREATE TABLE test_varchar_no_padding (id INT, col_varchar VARCHAR(10));

statement ok
INSERT INTO test_varchar_no_padding VALUES (1, 'ABC');

query T
SELECT LENGTHB(col_varchar) as varchar_length FROM test_varchar_no_padding;
----
3

statement ok
DROP TABLE test_varchar_no_padding;


# Test Case 8/32
# 字符类型-TEXT-NULL值测试
# 测试TEXT类型的NULL值处理

statement ok
DROP TABLE IF EXISTS test_text_null;


statement ok
CREATE TABLE test_text_null (id INT, col_text TEXT);

statement ok
INSERT INTO test_text_null VALUES (1, NULL), (2, 'Some text');

query TT
SELECT id, col_text FROM test_text_null WHERE col_text IS NULL;
----
1 NULL

statement ok
DROP TABLE test_text_null;


# Test Case 9/32
# 字符类型-CLOB-空CLOB测试
# 测试CLOB类型的空值处理

statement ok
DROP TABLE IF EXISTS test_clob_empty;


statement ok
CREATE TABLE test_clob_empty (id INT, col_clob CLOB);

statement ok
INSERT INTO test_clob_empty VALUES (1, EMPTY_CLOB());

query TT
SELECT id, LENGTHB(col_clob) as clob_length FROM test_clob_empty;
----
1 0

statement ok
DROP TABLE test_clob_empty;


# Test Case 10/32
# 字符类型-多字节字符-UTF8编码测试
# 测试UTF-8编码下多字节字符的存储

statement ok
DROP TABLE IF EXISTS test_multibyte_utf8;

statement ok
CREATE TABLE test_multibyte_utf8 (id INT, col_varchar VARCHAR(50));

statement ok
INSERT INTO test_multibyte_utf8 VALUES (1, '中文'), (2, '日本語'), (3, '한국어'), (4, 'Русский');

query TTTT
SELECT id, col_varchar, LENGTHB(col_varchar) as byte_count FROM test_multibyte_utf8 ORDER BY id;
----
1 中文 6
2 日本語 9
3 한국어 9
4 Русский 14

statement ok
DROP TABLE test_multibyte_utf8;


# Test Case 11/32
# 字符类型-Emoji表情符号测试
# 测试存储Emoji表情符号

statement ok
DROP TABLE IF EXISTS test_emoji;


statement ok
CREATE TABLE test_emoji (id INT, col_varchar VARCHAR(100));

statement ok
INSERT INTO test_emoji VALUES (1, '😀😃😄'), (2, '❤️💕💖'), (3, '🚀🛸✈️');

query TT
SELECT id, col_varchar FROM test_emoji ORDER BY id;
----
1 😀😃😄
2 ❤️💕💖
3 🚀🛸✈️

statement ok
DROP TABLE test_emoji;


# Test Case 12/32
# 字符类型-控制字符测试
# 测试存储各种控制字符

statement ok
DROP TABLE IF EXISTS test_control_chars;


statement ok
CREATE TABLE test_control_chars (id INT, col_varchar VARCHAR(50));

statement ok
INSERT INTO test_control_chars VALUES (1, 'Line1
Line2'), (2, 'Tab	Separated'), (3, 'Carriage
Return');

query TT
SELECT id, col_varchar FROM test_control_chars ORDER BY id;
----
1 Line1
Line2
2 Tab	Separated
3 Carriage
Return

statement ok
DROP TABLE test_control_chars;


# Test Case 13/32
# 字符类型-SQL注入防护测试
# 测试包含SQL特殊字符的字符串存储

statement ok
DROP TABLE IF EXISTS test_sql_special_chars;


statement ok
CREATE TABLE test_sql_special_chars (id INT, col_varchar VARCHAR(100));

statement ok
INSERT INTO test_sql_special_chars VALUES (1, 'O''Reilly'), (2, 'SELECT * FROM users'), (3, '1'' OR ''1''=''1');

query TT
SELECT id, col_varchar FROM test_sql_special_chars ORDER BY id;
----
1 O'Reilly
2 SELECT * FROM users
3 1' OR '1'='1

statement ok
DROP TABLE test_sql_special_chars;


# Test Case 14/32
# 字符类型-REPLACE函数测试
# 测试字符串替换函数REPLACE

statement ok
DROP TABLE IF EXISTS test_replace_func;


statement ok
CREATE TABLE test_replace_func (id INT, col_varchar VARCHAR(50));

statement ok
INSERT INTO test_replace_func VALUES (1, 'Hello World'), (2, 'DaMeng Database');

query TT
SELECT id, REPLACE(col_varchar, 'World', 'China') as replaced_text FROM test_replace_func ORDER BY id;
----
1 Hello China
2 DaMeng Database

statement ok
DROP TABLE test_replace_func;


# Test Case 15/32
# 字符类型-INSTR函数测试
# 测试字符串位置查找函数INSTR

statement ok
DROP TABLE IF EXISTS test_instr_func;


statement ok
CREATE TABLE test_instr_func (id INT, col_varchar VARCHAR(50));

statement ok
INSERT INTO test_instr_func VALUES (1, 'Hello World'), (2, 'DaMeng Database'), (3, 'Test String');

query TT
SELECT id, INSTR(col_varchar, 'a') as position FROM test_instr_func ORDER BY id;
----
1 0
2 2
3 0

statement ok
DROP TABLE test_instr_func;


# Test Case 16/32
# 字符类型-LPAD_RPAD函数测试
# 测试左右填充函数LPAD和RPAD

statement ok
DROP TABLE IF EXISTS test_pad_func;


statement ok
CREATE TABLE test_pad_func (id INT, col_varchar VARCHAR(10));

statement ok
INSERT INTO test_pad_func VALUES (1, 'ABC'), (2, 'XYZ');

query TTT
SELECT id, LPAD(col_varchar, 10, '*') as lpadded, RPAD(col_varchar, 10, '*') as rpadded FROM test_pad_func ORDER BY id;
----
1 *******ABC ABC*******
2 *******XYZ XYZ*******

statement ok
DROP TABLE test_pad_func;


# Test Case 17/32
# 字符类型-LTRIM_RTRIM函数测试
# 测试左右去空格函数LTRIM和RTRIM

statement ok
DROP TABLE IF EXISTS test_trim_lr;


statement ok
CREATE TABLE test_trim_lr (id INT, col_varchar VARCHAR(30));

statement ok
INSERT INTO test_trim_lr VALUES (1, '   Leading Spaces'), (2, 'Trailing Spaces   '), (3, '   Both Sides   ');

query TTTT
SELECT id, LTRIM(col_varchar) as ltrimmed, RTRIM(col_varchar) as rtrimmed, TRIM(col_varchar) as trimmed FROM test_trim_lr ORDER BY id;
----
1 Leading Spaces    Leading Spaces Leading Spaces
2 Trailing Spaces    Trailing Spaces Trailing Spaces
3 Both Sides       Both Sides Both Sides

statement ok
DROP TABLE test_trim_lr;


# Test Case 18/32
# 字符类型-ASCII函数测试
# 测试ASCII码转换函数

statement ok
DROP TABLE IF EXISTS test_ascii_func;


statement ok
CREATE TABLE test_ascii_func (id INT, col_varchar VARCHAR(10));

statement ok
INSERT INTO test_ascii_func VALUES (1, 'A'), (2, 'Z'), (3, '0'), (4, '9');

query TTT
SELECT id, col_varchar, ASCII(col_varchar) as ascii_value FROM test_ascii_func ORDER BY id;
----
1 A 65
2 Z 90
3 0 48
4 9 57

statement ok
DROP TABLE test_ascii_func;


# Test Case 19/32
# 字符类型-CHR函数测试
# 测试ASCII码转字符函数CHR

statement ok
DROP TABLE IF EXISTS test_chr_func;


statement ok
CREATE TABLE test_chr_func (id INT, ascii_value INT);

statement ok
INSERT INTO test_chr_func VALUES (1, 65), (2, 90), (3, 48), (4, 57);

query TT
SELECT id, CHR(ascii_value) as char_value FROM test_chr_func ORDER BY id;
----
1 A
2 Z
3 0
4 9

statement ok
DROP TABLE test_chr_func;


# Test Case 20/32
# 字符类型-INITCAP函数测试
# 测试首字母大写函数INITCAP

statement ok
DROP TABLE IF EXISTS test_initcap_func;


statement ok
CREATE TABLE test_initcap_func (id INT, col_varchar VARCHAR(50));

statement ok
INSERT INTO test_initcap_func VALUES (1, 'hello world'), (2, 'DAMENG DATABASE'), (3, 'tEsT sTrInG');

query TT
SELECT id, INITCAP(col_varchar) as initcap_text FROM test_initcap_func ORDER BY id;
----
1 Hello World
2 Dameng Database
3 Test String

statement ok
DROP TABLE test_initcap_func;


# Test Case 21/32
# 字符类型-REVERSE函数测试
# 测试字符串反转函数REVERSE

statement ok
DROP TABLE IF EXISTS test_reverse_func;


statement ok
CREATE TABLE test_reverse_func (id INT, col_varchar VARCHAR(30));

statement ok
INSERT INTO test_reverse_func VALUES (1, 'ABCDEF'), (2, '123456'), (3, 'Hello');

query TTT
SELECT id, col_varchar, REVERSE(col_varchar) as reversed FROM test_reverse_func ORDER BY id;
----
1 ABCDEF FEDCBA
2 123456 654321
3 Hello olleH

statement ok
DROP TABLE test_reverse_func;


# Test Case 22/32
# 字符类型-LIKE通配符百分号测试
# 测试LIKE模式匹配中%通配符的使用

statement ok
DROP TABLE IF EXISTS test_like_percent;


statement ok
CREATE TABLE test_like_percent (id INT, product VARCHAR(50));

statement ok
INSERT INTO test_like_percent VALUES (1, 'iPhone 13'), (2, 'iPhone 14'), (3, 'iPad Pro'), (4, 'MacBook Pro'), (5, 'Samsung Galaxy');

query T
SELECT product FROM test_like_percent WHERE product LIKE 'iPhone%' ORDER BY id;
----
iPhone 13
iPhone 14

statement ok
DROP TABLE test_like_percent;


# Test Case 23/32
# 字符类型-LIKE通配符下划线测试
# 测试LIKE模式匹配中_通配符的使用

statement ok
DROP TABLE IF EXISTS test_like_underscore;


statement ok
CREATE TABLE test_like_underscore (id INT, code VARCHAR(10));

statement ok
INSERT INTO test_like_underscore VALUES (1, 'A001'), (2, 'A002'), (3, 'B001'), (4, 'A101'), (5, 'A999');

query T
SELECT code FROM test_like_underscore WHERE code LIKE 'A_0_' ORDER BY id;
----
A001
A002
A101

statement ok
DROP TABLE test_like_underscore;


# Test Case 24/32
# 字符类型-LIKE转义字符测试
# 测试LIKE模式匹配中ESCAPE转义字符

statement ok
DROP TABLE IF EXISTS test_like_escape;


statement ok
CREATE TABLE test_like_escape (id INT, pattern VARCHAR(30));

statement ok
INSERT INTO test_like_escape VALUES (1, '100% Success'), (2, '50% Complete'), (3, 'Test_Data'), (4, 'No Special');

query T
SELECT pattern FROM test_like_escape WHERE pattern LIKE '%\%%' ESCAPE '\' ORDER BY id;
----
100% Success
50% Complete

statement ok
DROP TABLE test_like_escape;


# Test Case 25/32
# 字符类型-NOT_LIKE测试
# 测试NOT LIKE模式不匹配

statement ok
DROP TABLE IF EXISTS test_not_like;


statement ok
CREATE TABLE test_not_like (id INT, email VARCHAR(50));

statement ok
INSERT INTO test_not_like VALUES (1, 'user@gmail.com'), (2, 'admin@qq.com'), (3, 'test@163.com'), (4, 'info@yahoo.com');

query T
SELECT email FROM test_not_like WHERE email NOT LIKE '%@gmail.com' ORDER BY id;
----
admin@qq.com
test@163.com
info@yahoo.com

statement ok
DROP TABLE test_not_like;


# Test Case 26/32
# 字符类型-正则表达式REGEXP_LIKE测试
# 测试正则表达式模式匹配

statement ok
DROP TABLE IF EXISTS test_regexp;


statement ok
CREATE TABLE test_regexp (id INT, phone VARCHAR(20));

statement ok
INSERT INTO test_regexp VALUES (1, '13812345678'), (2, '15987654321'), (3, '12345678901'), (4, '18611112222');

query T
SELECT phone FROM test_regexp WHERE REGEXP_LIKE(phone, '^1[3-9][0-9]{9}$') ORDER BY id;
----
13812345678
15987654321
18611112222

statement ok
DROP TABLE test_regexp;


# Test Case 27/32
# 字符类型-字符串连接性能测试
# 测试大量字符串连接的性能

statement ok
DROP TABLE IF EXISTS test_concat_performance;


statement ok
CREATE TABLE test_concat_performance (id INT, str1 VARCHAR(100), str2 VARCHAR(100), str3 VARCHAR(100));

statement ok
INSERT INTO test_concat_performance VALUES (1, 'Part1', 'Part2', 'Part3'), (2, 'Section1', 'Section2', 'Section3');

query TT
SELECT id, str1 || '-' || str2 || '-' || str3 as concatenated FROM test_concat_performance ORDER BY id;
----
1 Part1-Part2-Part3
2 Section1-Section2-Section3

statement ok
DROP TABLE test_concat_performance;


# Test Case 28/32
# 字符类型-ORDER_BY排序规则测试
# 测试不同字符的排序规则

statement ok
DROP TABLE IF EXISTS test_collation_order;


statement ok
CREATE TABLE test_collation_order (id INT, value VARCHAR(10));

statement ok
INSERT INTO test_collation_order VALUES (1, 'apple'), (2, 'Apple'), (3, 'APPLE'), (4, 'banana'), (5, 'Banana');

query T
SELECT value FROM test_collation_order ORDER BY value;
----
APPLE
Apple
Banana
apple
banana

statement ok
DROP TABLE test_collation_order;


# Test Case 29/32
# 字符类型-GROUP_BY聚合测试
# 测试字符类型的GROUP BY聚合

statement ok
DROP TABLE IF EXISTS test_group_by_char;


statement ok
CREATE TABLE test_group_by_char (category VARCHAR(20), product VARCHAR(50), price DECIMAL(10,2));

statement ok
INSERT INTO test_group_by_char VALUES ('Electronics', 'Phone', 999.99), ('Electronics', 'Laptop', 1999.99), ('Books', 'Novel', 29.99), ('Books', 'Textbook', 89.99);

query TTT
SELECT category, COUNT(*) as product_count, AVG(price) as avg_price FROM test_group_by_char GROUP BY category ORDER BY category;
----
Books 2 59.99
Electronics 2 1499.99

statement ok
DROP TABLE test_group_by_char;


# Test Case 30/32
# 字符类型-DISTINCT去重测试
# 测试字符类型的去重功能

statement ok
DROP TABLE IF EXISTS test_distinct_char;


statement ok
CREATE TABLE test_distinct_char (id INT, tag VARCHAR(20));

statement ok
INSERT INTO test_distinct_char VALUES (1, 'important'), (2, 'urgent'), (3, 'important'), (4, 'normal'), (5, 'urgent');

query T
SELECT DISTINCT tag FROM test_distinct_char ORDER BY tag;
----
important
normal
urgent

statement ok
DROP TABLE test_distinct_char;


# Test Case 31/32
# 字符类型-UNION联合查询测试
# 测试字符类型的UNION操作

statement ok
DROP TABLE IF EXISTS test_union_char1;


statement ok
CREATE TABLE test_union_char1 (name VARCHAR(30));

statement ok
DROP TABLE IF EXISTS test_union_char2;


statement ok
CREATE TABLE test_union_char2 (name VARCHAR(30));

statement ok
INSERT INTO test_union_char1 VALUES ('Alice'), ('Bob'), ('Charlie');

statement ok
INSERT INTO test_union_char2 VALUES ('Bob'), ('David'), ('Eve');

query T
SELECT name FROM test_union_char1 UNION SELECT name FROM test_union_char2 ORDER BY name;
----
Alice
Bob
Charlie
David
Eve

statement ok
DROP TABLE test_union_char2;

statement ok
DROP TABLE test_union_char1;


# Test Case 32/32
# 字符类型-CHECK约束字符串长度测试
# 测试CHECK约束验证字符串长度

statement ok
DROP TABLE IF EXISTS test_check_length;


statement ok
CREATE TABLE test_check_length (id INT PRIMARY KEY, username VARCHAR(20) CHECK (LENGTH(username) >= 6));

statement error
INSERT INTO test_check_length VALUES (1, 'user');

statement ok
DROP TABLE IF EXISTS test_check_length;
